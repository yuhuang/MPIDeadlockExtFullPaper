
# we thought that we could solve the problem introduced by tests/fixtures/5.ctp
# by controlling the scheduler of the abstract machine
#
# by switching to a priority scheduler (instead of round robin) we could run
# deadlock candidate processes as much as possible and other processes as little
# as possible
#
# we could stop as soon as the candidate was reached, regardless of where the other
# processes ended
#
# the hard thing about this is that we have to prioritize the non-deadlock candidate
# processes too once the deadlock candidate processes have all blocked
#
# sometimes this is easy, for example, if a deadlock candidate process is blocked on
# a send or deterministic recv, the process to prioritize is immediately apparent
#
# but if it is blocked on a wildcard recv, which process do we prioritize?
# ideally, any process with a compatible send would be a valid choice in this situation
#
# the idea with this program is to try and trick the analysis into picking the wrong
# process to prioritize in the abstract machine and end up consuming a set of actions
# that is not associated with the feasible deadlock execution that exists
#
# but the analysis out smarted us by detecting a more specific deadlock candidate than we anticipated
# we expected the analysis to find the candidate [(w 0 4), (w 3 2), (b 4 0)] where (b 4 0) is the final barrier added to the program
# in this case the machine would have to choose between (s 1 0 0) and (s 2 0 0) to match with (r 0 -1 0)
# if it chose (s 1 0 0), then the machine state would allow it to reach the deadlock candidate without
# actually issuing enough sends to reach it in a concrete execution (due to the extra sends generated by the abstract machine)
#
# however, the analysis also reported a cycle for the candidate [(w 0 4), (w 2 0), (w 3 2), (b 4 0)]
# this candidate precludes our trick because it includes process 2 as a deadlock process
# a counter example for the abstract machine always delivering valid full program points is still elusive...
#
# another interesting thing about this program is that the machine finds the same deadlock from 4 distinct
# deadlock candidates that all share [(w 3 2), (b 4 0)] as a subset

r 0 -1 0
w 0 0
r 0 1 2
w 0 2
s 0 3 4
w 0 4
r 0 -1 6
w 0 6

s 1 0 0
w 1 0
s 1 0 2
w 1 2

s 2 0 0
w 2 0

r 3 -1 0
w 3 0
r 3 4 2
w 3 2

s 4 3 0
w 4 0

